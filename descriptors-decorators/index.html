<!DOCTYPE html>
<html lang="en"  class="theme--light" >

<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, viewport-fit=cover">
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://rmariano.eu/images/apple-touch-icon-144x144.png" />
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="https://rmariano.eu/images/apple-touch-icon-120x120.png" />
  <link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://rmariano.eu/images/apple-touch-icon-72x72.png" />
  <link rel="apple-touch-icon-precomposed" sizes="57x57" href="https://rmariano.eu/images/apple-touch-icon-57x57.png" />
  <link rel="short icon" href="https://rmariano.eu/images/favicon.png" type="image/x-icon" />
  <link rel="stylesheet" href="https://rmariano.eu/style.css">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" rel="stylesheet">
  <title>IT Arch â€¢ Descriptors &amp; Decorators</title>
  
  
  
</head>

<body>
  <div id="sidebar" class="animated fadeInDown">
    <div class="logo-title">
      <div class="title">
        <img src=https://rmariano.eu/images/logo@2x.png style="width:127px;" alt="logo" />
        <h3><a href="https://rmariano.eu/">IT Arch</a></h3>
        <div class="description">
          <p>A blog about software engineering.</p>
        </div>
      </div>
    </div>
    <ul class="social-links"><li><a href="https://github.com/rmariano" aria-label="Go to Github profile page"><i class="fab fa-github"></i></a></li><li><a href="https://gitlab.com/rmariano" aria-label="Go to Gitlab profile page"><i class="fab fa-gitlab"></i></a></li><li><a href="https://twitter.com/rmarianoa" aria-label="Go to Twitter profile page"><i class="fab fa-twitter"></i></a></li>
      
    </ul>
  </div>
  <div id="main">
    <div class="page-top animated fadeInDown">
      <div class="nav">
        
        
        
        
        <li><a  href="https://rmariano.eu/">Home</a></li>
        <li><a  href="https://rmariano.eu/about/">About</a></li><li><a  href="https://rmariano.eu/tags">Tags</a></li><li><a 
            href="https://rmariano.eu/archive/">Archive</a></li></div>
      <div class="information">
        <div class="back_btn">
          <a onclick="window.history.go(-1)" ><i
              class="fas fa-chevron-left"></i></a>
        </div>
        
        
        
        <div class="avatar"><img src="https://rmariano.eu/images/avatar.jpg"></div>
      </div>
    </div>
    <div class="autopagerize_page_element">
      <div class="content">
        
<article class="post animated fadeInDown">
  <h1><a href="https:&#x2F;&#x2F;rmariano.eu&#x2F;descriptors-decorators&#x2F;">Descriptors &amp; Decorators</a></h1>
  
  <div class="post-content"><p>Descriptors are an amazing tool to have in our toolbox, as they come in
handy in many opportunities.</p>
<p>Probably the best thing about descriptors, is that they can improve
other solutions. Let's see how we can write better decorators, by using
descriptors.</p>
<h1 id="decorate-a-class-method">Decorate a class method</h1>
<p>Imagine we have a very simple decorator, that does nothing but returning
a text, with what the original function returns:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">decorator</span><span style="color:#eff1f5;">:
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#96b5b4;">__init__</span><span>(</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">func</span><span>):
</span><span>        </span><span style="color:#bf616a;">self</span><span>.func = func
</span><span>        </span><span style="color:#bf616a;">wraps</span><span>(func)(</span><span style="color:#bf616a;">self</span><span>)
</span><span>
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#96b5b4;">__call__</span><span>(</span><span style="color:#bf616a;">self</span><span>, *</span><span style="color:#bf616a;">args</span><span>, **</span><span style="color:#bf616a;">kwargs</span><span>):
</span><span>        result = </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#bf616a;">func</span><span>(*args, **kwargs)
</span><span>        </span><span style="color:#b48ead;">return f</span><span>&quot;</span><span style="color:#a3be8c;">decorated </span><span>{result}&quot;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Object</span><span style="color:#eff1f5;">:
</span><span>    @</span><span style="color:#bf616a;">decorator
</span><span>    @</span><span style="color:#96b5b4;">classmethod
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">class_method</span><span>(</span><span style="color:#bf616a;">cls</span><span>):
</span><span>        </span><span style="color:#b48ead;">return </span><span>&#39;</span><span style="color:#a3be8c;">class method</span><span>&#39;
</span></code></pre>
<p>If we apply the decorator to a simple function, it'll work, as
expected. However, when it's applied to a class method, we can see an
error:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span>    &gt;&gt;&gt; Object.</span><span style="color:#bf616a;">class_method</span><span>()
</span><span>    </span><span style="color:#bf616a;">Traceback </span><span>(most recent call last):
</span><span>    </span><span style="color:#d08770;">...
</span><span>    TypeError: &#39;</span><span style="color:#a3be8c;">classmethod</span><span>&#39; object is not </span><span style="color:#96b5b4;">callable
</span></code></pre>
<p>The exception is telling us that we tried to call something that is not
actually a callable. But if that's the case then, how do class methods
run?</p>
<p>The fact is that, this is true, class methods are indeed not callable
objects, but we rarely notice this, because when we access a class
method, it's usually in the form of
<code>&lt;class&gt;.&lt;class_method&gt;</code> (or maybe also from an instance
doing <code>self.&lt;class_method&gt;</code>). For both cases the answer is the same: by
calling the method like this, the <em>descriptor mechanism</em> is triggered,
and will call the <code>__get__</code> inside the class method. As we already know
from the analysis of the <code>types-of-descriptors</code>, <code>@classmethod</code> is actually a descriptor, and the definition
of its <code>__get__</code> method is the one that returns a callable<sup class="footnote-reference"><a href="#1">1</a></sup>, but
<code>@classmethod</code> is not itself a callable.</p>
<hr />
<p><strong>HINT</strong></p>
<p><code>@classmethod</code> is not a callable object. It's a descriptor whose
<code>__get__</code> method returns a callable.</p>
<hr />
<p>Now, when the decorator is applied to the class method, this is
equivalent of doing:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Object</span><span style="color:#eff1f5;">:
</span><span>    </span><span style="color:#d08770;">...
</span><span>    class_method = </span><span style="color:#bf616a;">decorator</span><span>(class_method)
</span></code></pre>
<p>Which doesn't trigger the <em>descriptor protocol</em>, so the <code>__get__</code> in
<code>@classmethod</code> is never called, therefore what the decorator receives,
is not a callable, hence the exception.</p>
<p>By now, it becomes clear that if the reason why it fails is because
<code>@classmethod</code> is a non-callable descriptor, then the solution must be
related to descriptors. And indeed, this can be fixed by just
implementing <code>__get__</code>.</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">decorator</span><span style="color:#eff1f5;">:
</span><span>    </span><span style="color:#d08770;">...
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#96b5b4;">__get__</span><span>(</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">instance</span><span>, </span><span style="color:#bf616a;">owner</span><span>):
</span><span>        mapped = </span><span style="color:#bf616a;">self</span><span>.func.</span><span style="color:#96b5b4;">__get__</span><span>(instance, owner)
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#bf616a;">__class__</span><span>(mapped)
</span></code></pre>
<p>This links the function of the descriptor to the object that is going to
use it (in this case, the class), and returns a new instance of the
decorator for this function, which does the trick.</p>
<p>It's important to notice that this error was due to the order on which
descriptors where applied, because <code>@decorator</code> was decorating
<code>@classmethod</code> and not the other way around. This problem wouldn't have
occurred if we swapped the order of the decorators. So it's a fair
question to ask, why wasn't this just applied like this to begin with?
After all, a class method-like functionality is orthogonal from every
other sort of decoration we might want to apply, so it makes sense to be
it the last one being applied. True, but the fix is rather simple, and
more importantly, it makes the decorator more generic and applicable, as
it's shown on the next section.</p>
<hr />
<p><strong>NOTE</strong></p>
<p>Keep in mind the order of the decorators, and make sure <code>@classmethod</code>
is the last one being used, in order to avoid issues. Even despite this
consideration, is better to have decorators that will work in many
possible scenarios, regardless of their order.</p>
<hr />
<p>The complete code for this example can be found
<a href="https://gist.github.com/rmariano/0c401b79add51bca844429ca5a303e06#file-descriptors2_args0-py">here</a></p>
<h1 id="decorators-that-change-the-signature">Decorators that change the signature</h1>
<p>Scenario: Several parts of the code have callable objects that interact
with their parameters in the same way, resulting in code repetition. As
a result of that, a decorator is devised in order to abstract that logic
in a single place.</p>
<p>For example, we have a function that resolves some attributes based on
its parameters, but it does so, by using a helper object, created from
the parameters, like this:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">resolver_function</span><span>(</span><span style="color:#bf616a;">root</span><span>, </span><span style="color:#bf616a;">args</span><span>, </span><span style="color:#bf616a;">context</span><span>, </span><span style="color:#bf616a;">info</span><span>):
</span><span>    helper = </span><span style="color:#bf616a;">DomainObject</span><span>(root, args, context, info)
</span><span>    </span><span style="color:#d08770;">...
</span><span>    helper.</span><span style="color:#bf616a;">process</span><span>()
</span><span>    helper.</span><span style="color:#bf616a;">task1</span><span>()
</span><span>    helper.</span><span style="color:#bf616a;">task2</span><span>()
</span><span>    </span><span style="color:#b48ead;">return </span><span>helper.</span><span style="color:#bf616a;">task1</span><span>()
</span></code></pre>
<p>If there are more functions with this signature doing the same as in the
first lines, it'll be better to abstract this away, and simply receive
the helper object directly. A decorator like this one should work:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">DomainArgs</span><span style="color:#eff1f5;">:
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#96b5b4;">__init__</span><span>(</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">func</span><span>):
</span><span>        </span><span style="color:#bf616a;">self</span><span>.func = func
</span><span>        </span><span style="color:#bf616a;">wraps</span><span>(func)(</span><span style="color:#bf616a;">self</span><span>)
</span><span>
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#96b5b4;">__call__</span><span>(</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">root</span><span>, </span><span style="color:#bf616a;">args</span><span>, </span><span style="color:#bf616a;">context</span><span>, </span><span style="color:#bf616a;">info</span><span>):
</span><span>        helper = </span><span style="color:#bf616a;">DomainObject</span><span>(root, args, context, info)
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#bf616a;">func</span><span>(helper)
</span></code></pre>
<p>This decorator changes the signature of the original function.
Therefore, we decorate a function that will receive a single argument,
when in fact (thanks to the decorator), the resulting one will end up
receiving the same old four arguments, maintaining compatibility. By
applying the decorator, we could happily assume that the required object
will be passed by:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span>@</span><span style="color:#bf616a;">DomainArgs
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">resolver_function2</span><span>(</span><span style="color:#bf616a;">helper</span><span>):
</span><span>    helper.</span><span style="color:#bf616a;">task1</span><span>()
</span><span>    helper.</span><span style="color:#bf616a;">task2</span><span>()
</span><span>    </span><span style="color:#d08770;">...
</span><span>    </span><span style="color:#b48ead;">return </span><span>helper.</span><span style="color:#bf616a;">process</span><span>()
</span></code></pre>
<p>However, there are also objects whose methods have this logic, and we
want to apply the same decorator to them:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">ViewResolver</span><span style="color:#eff1f5;">:
</span><span>    @</span><span style="color:#bf616a;">DomainArgs
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">resolve_method</span><span>(</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">helper</span><span>):
</span><span>        response = helper.</span><span style="color:#bf616a;">process</span><span>()
</span><span>        </span><span style="color:#b48ead;">return f</span><span>&quot;</span><span style="color:#a3be8c;">Method: </span><span>{response}&quot;
</span></code></pre>
<p>But with this implementation, it won't work:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span>
</span><span>    &gt;&gt;&gt; vr = </span><span style="color:#bf616a;">ViewResolver</span><span>()
</span><span>    &gt;&gt;&gt; vr.</span><span style="color:#bf616a;">resolve_method</span><span>(&#39;</span><span style="color:#a3be8c;">root</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">args</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">context</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">info</span><span>&#39;)
</span><span>    </span><span style="color:#bf616a;">Traceback </span><span>(most recent call last)
</span><span>    </span><span style="color:#d08770;">...
</span><span>         </span><span style="color:#d08770;">39     </span><span style="background-color:#bf616a;color:#2b303b;">def</span><span> </span><span style="color:#96b5b4;">__call__</span><span>(</span><span style="color:#bf616a;">self</span><span>, root, args, context, info):
</span><span>         </span><span style="color:#d08770;">40         </span><span>helper = </span><span style="color:#bf616a;">DomainObject</span><span>(root, args, context, info)
</span><span>    ---&gt; </span><span style="color:#d08770;">41         </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#bf616a;">func</span><span>(helper)
</span><span>    TypeError: </span><span style="color:#bf616a;">resolve_method</span><span>() missing </span><span style="color:#d08770;">1 </span><span>required positional argument: &#39;</span><span style="color:#a3be8c;">helper</span><span>&#39;
</span></code></pre>
<p>The problem is that instance methods are functions, that take an extra
first parameter, namely <em>self</em>, which is the instance itself. In this
case, the error shown in line 41, means that the decorator is composing
the object as usually, and passes it was the first parameter, in the
place where <em>self</em> would go for the method, and there is nothing being
passed for <em>helper</em> (the parameters are &quot;shifted&quot; on place to the
left), hence the error.</p>
<p>In order to fix this, we need to distinguish when the wrapped function
is being called from an instance or a class. And descriptors do just
that, so the fix is rather simple as in the previous case:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">def </span><span style="color:#96b5b4;">__get__</span><span>(</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">instance</span><span>, </span><span style="color:#bf616a;">owner</span><span>):
</span><span>    mapped = </span><span style="color:#bf616a;">self</span><span>.func.</span><span style="color:#96b5b4;">__get__</span><span>(instance, owner)
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#bf616a;">__class__</span><span>(mapped)
</span></code></pre>
<p>The same method works here as well. When the wrapped function is a
regular one, the <code>__get__</code> method doesn't take place at all, so adding
it, doesn't affect the decorator. Whereas, when is called from a class,
the <code>__get__</code> method is enabled, returning a bound instance, which will
pass <em>self</em> as the first parameter (what Python does internally).</p>
<hr />
<p><strong>HINT</strong></p>
<p>Descriptors can help writing better decorators, by fixing common
problems in a very elegant fashion.</p>
<hr />
<p><a href="https://gist.github.com/rmariano/0c401b79add51bca844429ca5a303e06#file-descriptors2_classmethod0-py">Here is</a> the listing for
this example.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>An equivalent Python implementation of classmethod and others can
be found at
<a href="https://docs.python.org/3.6/howto/descriptor.html#descriptor-protocol">https://docs.python.org/3.6/howto/descriptor.html#descriptor-protocol</a></p>
</div>
</div>
  <div class="post-footer">
    <div class="meta">
      <div class="info">
        
        <i class="far fa-sun"></i><span class="date">Sun May 21, 2017 17:22:05 -0200</span>
        
        
        <i class="fas fa-tags"></i>
        
        <a class="tag" href="https://rmariano.eu/tags/python">&nbsp;python</a>
        
        <a class="tag" href="https://rmariano.eu/tags/descriptors">&nbsp;descriptors</a>
        
        <a class="tag" href="https://rmariano.eu/tags/featured">&nbsp;featured</a>
        
        <a class="tag" href="https://rmariano.eu/tags/decorators">&nbsp;decorators</a>
        
        
      </div>
    </div>
  </div>
</article>
<div class="share">
  <div class="twitter">
    <a class="fab fa-twitter"
      href="http://twitter.com/share?text=Descriptors &amp; Decorators&url=https:&#x2F;&#x2F;rmariano.eu&#x2F;descriptors-decorators&#x2F;&hashtags=python,descriptors,featured,decorators"></a>
  </div>
</div>










      </div>
    </div>
  </div>
  
  <script>
    function showLanguages() {
      let currentDisplay = document.getElementById("languages").style.display;
      if (currentDisplay == 'none') {
        document.getElementById("languages").style.display = 'block';
      } else {
        document.getElementById("languages").style.display = 'none';
      }
    }
  </script>
</body>

</html>
